require "active_support"
require "active_support/core_ext"
require 'json'
require 'nokogiri'
require 'pathname'
require 'yaml'
require 'open3'

Dir.chdir __dir__

ActiveSupport::Inflector.inflections(:en) do |inflect|
  inflect.acronym 'A1M1'
  inflect.acronym 'M2'
end

class Pathname
  alias to_str to_s
end

class Hash
  def sort_by_key
    map { |k, v| [k, v.is_a?(Hash) ? v.sort_by_key : v] }.sort_by { |k,| k }.to_h
  end
end

DATAPOINT_DEFINITION_VERSION_RAW                  = 'datapoint_definition_version_raw.yml'
DATAPOINT_DEFINITIONS_RAW                         = 'datapoint_definitions_raw.yml'
DATAPOINT_DEFINITIONS                             = 'datapoint_definitions.yml'
DATAPOINT_TYPES_RAW                               = 'datapoint_types_raw.yml'
DATAPOINT_TYPES                                   = 'datapoint_types.yml'
TRANSLATIONS_RAW                                  = 'translations_raw.yml'
SYSTEM_EVENT_TYPES_RAW                            = 'system_event_types_raw.yml'
SYSTEM_EVENT_TYPES                                = 'system_event_types.yml'
SYSTEM_DEVICE_IDENTIFIER_EVENT_TYPES_RAW          = 'system_device_identifier_event_types_raw.yml'
SYSTEM_DEVICE_IDENTIFIER_EXTENDED_EVENT_TYPES_RAW = 'system_device_identifier_extended_event_types_raw.yml'

DEVICES             = 'devices.yml'
MAPPINGS_UNIQUE     = 'mappings_unique.yml'
TRANSLATIONS_UNIQUE = 'translations_unique.yml'
USED_COMMANDS       = 'used_commands.yml'
USED_MAPPINGS       = 'used_mappings.yml'
USED_TRANSLATIONS   = 'used_translations.yml'
USED_DEVICES        = 'used_devices.yml'

TRANSLATION_FIXES = {
  'viessmann-ess.eventvaluetype.AnwahlDrsosselklappe~0'                   => 'viessmann-ess.eventvaluetype.AnwahlDrosselklappe~0',
  'viessmann-ess.eventvaluetype.AnwahlDrsosselklappe~1'                   => 'viessmann-ess.eventvaluetype.AnwahlDrosselklappe~1',
  'viessmann.eventvaluetype.name.WPR3_SGReady_Funktionen~0'               => 'viessmann.eventvaluetype.WPR3_SGReady_Funktionen~0',
  'viessmann.eventvaluetype.name.WPR3_SGReady_Funktionen~1'               => 'viessmann.eventvaluetype.WPR3_SGReady_Funktionen~1',
  'viessmann.eventvaluetype.name.WPR3_SGReady_Funktionen~2'               => 'viessmann.eventvaluetype.WPR3_SGReady_Funktionen~2',
  'viessmann.eventvaluetype.name.WPR3_SGReady_Funktionen~3'               => 'viessmann.eventvaluetype.WPR3_SGReady_Funktionen~3',
  'viessmann.eventvaluetype.WPR3_Split.K43_Flagtoindicateoper_shortLWT~0' => 'viessmann.eventvaluetype.WPR3_Split.K43_Flagtoindicateopen_shortLWT~0',
  'viessmann.eventvaluetype.WPR3_Split.K43_Flagtoindicateoper_shortLWT~2' => 'viessmann.eventvaluetype.WPR3_Split.K43_Flagtoindicateopen_shortLWT~2',
  'viessmann.eventvaluetype.WPR3_Split.K43_Flagtoindicateoper_shortLWT~3' => 'viessmann.eventvaluetype.WPR3_Split.K43_Flagtoindicateopen_shortLWT~3',
  'viessmann.eventvaluetype.K44_Flagtoindicateopen.shortICT~0'            => 'viessmann.eventvaluetype.K44_Flagtoindicateopen_shortICT~0',
  'viessmann.eventvaluetype.K44_Flagtoindicateopen.shortICT~2'            => 'viessmann.eventvaluetype.K44_Flagtoindicateopen_shortICT~2',
  'viessmann.eventvaluetype.K44_Flagtoindicateopen.shortICT~3'            => 'viessmann.eventvaluetype.K44_Flagtoindicateopen_shortICT~3',
  'viessmann.eventvaluetype.K45_Flagtoindicateoper/shortLWT~2'            => 'viessmann.eventvaluetype.K45_Flagtoindicateopen_shortICT~2',
  'viessmann.eventvaluetype.K45_Flagtoindicateoper/shortLWT~3'            => 'viessmann.eventvaluetype.K45_Flagtoindicateopen_shortICT~3',
}

EMPTY_VALUE_TRANSLATION = '@@viessmann-ess.eventvaluetype.ModulBetriebsart~3'

# Remove enum number from text representation if present.
def clean_enum_text(id, text)
  id = Regexp.escape(id)
  text.sub(/^(?:#{id}(?::)?\s+|\(0#{id}\))([^\s]+)/, '\1').strip
end

file USED_COMMANDS => [DEVICES, DATAPOINT_DEFINITIONS, SYSTEM_EVENT_TYPES, MAPPINGS_UNIQUE, TRANSLATIONS_UNIQUE] do |t|
  devices, datapoint_definitions, system_event_types, mappings_unique, translations_unique =
    t.sources.map { |source| load_yaml(source) }
  event_types = datapoint_definitions.fetch('event_types')

  used_event_type_ids = devices.each_value.reduce(Set.new) { |s, v| s | v['event_types'].to_set }

  used_event_types = system_event_types.merge(event_types.keep_if { |type_id,|
    used_event_type_ids.include?(type_id)
  })

  used_commands = used_event_types.reduce({}) { |h, (type_id, type)|
    command = type_to_command(type_id, type, mappings: mappings_unique, translations: translations_unique)
    h.merge({ command.delete('id') => command })
  }

  File.write t.name, used_commands.to_yaml
end

file USED_MAPPINGS => [USED_COMMANDS, MAPPINGS_UNIQUE, TRANSLATIONS_UNIQUE] do |t|
  used_commands, mappings_unique, translations_unique = t.sources.map { |source| load_yaml(source) }
  used_commands = used_commands.map { |_, v| v.fetch('type_id') }.to_set

  used_mappings = mappings_unique.fetch(:mapping)
    .select { |k, _| used_commands.include?(k) || k.match?(/\Aviessmann\.errorcode(?:\.|$)/) }
    .map { |_, k|
      [
        k,
        mappings_unique.fetch(:translations).fetch(k)
          .transform_values { |v| translations_unique.fetch(:mapping).fetch(v.delete_prefix('@@')) }
      ]
    }
    .to_h

  File.write t.name, used_mappings.to_yaml
end

file USED_TRANSLATIONS => [USED_MAPPINGS, TRANSLATIONS_UNIQUE] do |t|
  used_mappings, translations_unique = t.sources.map { |source| load_yaml(source) }

  used_translations = used_mappings.flat_map { |_, translations|
    translations.map { |mapping_index, translation_id|
      translation = translations_unique.fetch(:translations).fetch(translation_id).fetch('en')

      [
        translation_id,
        clean_enum_text(mapping_index.to_s, translation)
      ]
    }
  }.to_h

  File.write t.name, used_translations.to_yaml
end

file MAPPINGS_UNIQUE => [DATAPOINT_DEFINITIONS, SYSTEM_EVENT_TYPES, TRANSLATIONS_RAW] do |t|
  datapoint_definitions, system_event_types, translations = t.sources.map { |source| load_yaml(source) }
  event_types = datapoint_definitions.fetch('event_types')

  error_mappings = translations.each_key.reduce({}) { |h, translation_id|
    if /^(?<id>viessmann\.errorcode(?:\.SMS)?(?:\.[^.]+)?)\.(?<value>\h{2})$/ =~ translation_id
      h[id] ||= {}
      h[id][value.to_i(16)] = translation_id
    end

    h
  }

  mappings = system_event_types.merge(event_types).map { |event_type_id, event_type|
    value_list = event_type.fetch('value_list', {})
    next if value_list.empty?

    [event_type_id, value_list]
  }.compact.to_h

  File.write t.name, create_mapping_to_unique(mappings.merge(error_mappings)).to_yaml
end

def create_mapping_to_unique(input)
  reversed = {}

  input.each do |k, v|
    reversed[v] ||= []
    reversed[v] << k
    reversed[v] = reversed[v].sort.uniq
  end

  mapping = {}
  combined = {}

  reversed.each do |k, v|
    require 'digest'

    new_id = Digest::MD5.hexdigest(v.sort_by(&:length).first)

    v.each do |old_id|
      mapping[old_id] = new_id
    end

    combined[new_id] = k
  end

  {
    mapping: mapping,
    translations: combined,
  }.sort_by_key
end

file TRANSLATIONS_UNIQUE => TRANSLATIONS_RAW do |t|
  translations = load_yaml(t.sources.first)

  translations = translations.transform_keys { |k|
    TRANSLATION_FIXES.fetch(k, k)
  }

  File.write t.name, create_mapping_to_unique(translations).to_yaml
end

def map_command_id(id)
  exact_mappings = {
    'NRF_TiefpassTemperaturwert_PTSO'               => 'buffer_temperature_actual_1',
    'NRF_TiefpassTemperaturwert_PTSU'               => 'buffer_temperature_actual_2',
    'NRF_Temperaturanstieg_STSSOL'                  => 'buffer_temperature_desired',
    'NRF_Temperaturanstieg_PTSU'                    => 'buffer_temperature_actual_3',
    'NRF_Temperaturanstieg_VTSM2'                   => 'buffer_temperature_average',
    'SC100_KesselIsttemperatur'                     => 'boiler_temperature_actual',
    'SC100_Flammtemperatur'                         => 'flame_temperature_actual',
    'SC100_Einschubtemperatur'                      => 'slot_temperature_actual',
    'VT_SolltemperaturA1M1'                         => 'flow_temperature_desired_a1m1',
    'Ausgang52_Mischerposition_M1'                  => 'mixer_position_m1',
    'HK_Mischerposition_akt_M1'                     => 'mixer_position_m1',
    'VorlauftemperaturM1'                           => 'flow_temperature_actual_m1',
    'ADC_Isttemperaturwert_2'                       => 'flow_temperature_actual_m1',
    'Temperatur_2_M1'                               => 'flow_temperature_actual_m1',
    'VT_SolltemperaturM2'                           => 'flow_temperature_desired_m1',
    'VorlauftemperaturM2'                           => 'flow_temperature_actual_m2',
    'Temperatur_2_M2'                               => 'flow_temperature_actual_m2',
    'K90_KonfiZeitkonstAussentemperatur'            => 'outside_temperature_damping_time_constant',
    'Gemischte_AT'                                  => 'outside_temperature_damped',

    'BedienBetriebsartA1M1'                         => 'operating_mode_a1m1',
    'BedienBetriebsartM2'                           => 'operating_mode_m2',
    'Geraetekennung_Diode'                          => 'device_identification',
    'TiefpassTemperaturwert_ATS'                    => 'outside_temperature_lowpass',
    'ADC_IstTemperaturwert_ATS'                     => 'outside_temperature_actual',
    'ADC_IstTemperaturwert_AGTS'                    => 'exhaust_temperature_actual',
    'ADC_Isttemperaturwert_KTS'                     => 'boiler_temperature_actual',
    'TiefpassTemperaturwert_STS1'                   => 'dhw_temperature_lowpass',
    'ADC_IstTemperaturwert_STS1'                    => 'dhw_temperature_actual',
    'TemperaturFehler_STS1'                         => 'dhw_temperature_error',
    'Bedien_WW_Solltemperatur'                      => 'dhw_temperature_desired',
    'TemperaturFehler_AGTS'                         => 'exhaust_temperature_error',
    'TiefpassTemperaturwert_AGTS'                   => 'exhaust_temperature_lowpass',
    'AGTemperaturwertMAXBedienFunktionReset'        => 'exhaust_temperature_max_achieved_reset',
    'BedienRTSolltemperaturReduziertA1M1'           => 'room_temperature_desired_reduced_a1m1',
    'BedienRTSolltemperaturReduziertM2'             => 'room_temperature_desired_reduced_m2',
    'BedienRTSolltemperaturA1M1'                    => 'room_temperature_desired_a1m1',
    'BedienRTSolltemperaturM2'                      => 'room_temperature_desired_m2',
    'HK_RaumsolltemperaturaktuellA1M1'              => 'room_temperature_desired_effective_a1m1',
    'HK_RaumsolltemperaturaktuellM2'                => 'room_temperature_desired_effective_m2',
    'TiefpassTemperatur_RTS_A1M1'                   => 'room_temperature_lowpass_a1m1',
    'TiefpassTemperaturwert_RTS_M2'                 => 'room_temperature_lowpass_m2',
    'TiefpassTemperaturwert_KTS_A1'                 => 'flow_temperature_lowpass_a1m1',
    'HK_VT_Solltemperatur_A1M1'                     => 'flow_temperature_desired_a1m1',
    'HK_VT_Solltemperatur_M2'                       => 'flow_temperature_desired_m2',
    'TemperaturFehler_17_NR1'                       => 'return_temperature_error_status',
    'TiefpassTemperaturwert_17_NR1'                 => 'return_temperature_lowpass_nr1',
    'RuecklauftemperaturM2'                         => 'return_temperature_actual_m2',
    'TemperaturFehler_2_NR1'                        => 'flow_temperature_error_status',
    'TiefpassTemperaturwert_2_NR1'                  => 'flow_temperature_lowpass_nr1',
    'WW_SolltemperaturAktuell'                      => 'dhw_temperature_desired_effective',
    'Zubringerpumpe'                                => 'feed_pump',
    'HK_AktuelleBetriebsartA1M1'                    => 'heating_circuit_operating_mode_effective_a1m1',
    'HK_AktuelleBetriebsartM2'                      => 'heating_circuit_operating_mode_effective_m2',
    'FerienBeginnA1M1'                              => 'holiday_departure_date_a1m1',
    'FerienBeginnM2'                                => 'holiday_departure_date_m2',
    'FerienEndeA1M1'                                => 'holiday_return_date_a1m1',
    'FerienEndeM2'                                  => 'holiday_return_date_m2',
    'Brennertyp_aktuell'                            => 'burner_type_effective',
    'Brennerstarts'                                 => 'burner_starts',
    'BedienSparbetriebA1M1'                         => 'economy_mode_a1m1',
    'BedienSparbetriebM2'                           => 'economy_mode_m2',
    'BedienPartybetriebA1M1'                        => 'party_mode_a1m1',
    'BedienPartybetriebM2'                          => 'party_mode_m2',
    'BedienRTSoll_PartyA1M1'                        => 'party_mode_temperature_desired_a1m1',
    'BedienRTSoll_PartyM2'                          => 'party_mode_temperature_desired_m2',
    'BedienNiveauA1M1'                              => 'heating_curve_level_a1m1',
    'BedienNiveauM2'                                => 'heating_curve_level_m2',
    'BedienNeigungA1M1'                             => 'heating_curve_slope_a1m1',
    'BedienNeigungM2'                               => 'heating_curve_slope_m2',
    'TemperaturFehler_KTS'                          => 'boiler_temperature_error_status',
    'VT_SollKesselA1M1_NR1'                         => 'boiler_temperature_desired_a1m1_nr1',
    'VT_SollKesselM2_NR1'                           => 'boiler_temperature_desired_m2_nr1',
    'TiefpassTemperaturwert_KTS'                    => 'boiler_temperature_lowpass',
    'Absenkzeit_gelerntM2'                          => 'setback_period_experience_based',
    'AGTemperaturwertMAX'                           => 'exhaust_temperature_max_achieved',
    'AGTemperaturwertMAXBedien'                     => 'exhaust_temperature_max',
    'Aufheizgradient_gelerntA1M1'                   => 'heat_up_gradient_experience_based_a1m1',
    'Aufheizgradient_gelerntM2'                     => 'heat_up_gradient_experience_based_m2',
    'BetriebsstundenBrenner1Bedienung'              => 'burner_hours_stage_1',
    'BetriebsstundenBrenner1BedienungFunktionReset' => 'burner_hours_stage_1_reset',
    'BetriebsstundenBrenner2Bedienung'              => 'burner_hours_stage_2',
    'BetriebsstundenBrenner2BedienungFunktionReset' => 'burner_hours_stage_2_reset',
    'BrennerstartsFunktionReset'                    => 'burner_starts_reset',
    'HK_FerienbetriebA1M1'                          => 'holiday_program_a1m1',
    'HK_FerienbetriebM2'                            => 'holiday_program_m2',
    'HK_Frostgefahr_aktivA1M1'                      => 'frost_risk_a1m1',
    'HK_Frostgefahr_aktivM2'                        => 'frost_risk_m2',
    'HK_PumpenzustandA1M1'                          => 'heating_circuit_pump_a1m1',
    'HK_PumpenzustandM2'                            => 'heating_circuit_pump_m2',
    'HK_ReglervarianteA1M1'                         => 'controller_version_a1m1',
    'HK_ReglervarianteA1M1_NR1'                     => 'controller_version_a1m1_nr1',
    'HK_ReglervarianteM2'                           => 'controller_version_m2',
    'HK_ReglervarianteM2_NR1'                       => 'controller_version_m2_nr1',
    'Uhrzeit'                                       => 'date_time',
    'AutomaticFlag_WWA1M1'                          => 'dhw_switching_times_mode_a1m1',
    'AutomaticFlag_WWM2'                            => 'dhw_switching_times_mode_m2',
    'AutomaticFlag_ZPA1M1'                          => 'dhw_circulation_pump_switching_times_mode_a1m1',
    'Schaltzeiten_A1M1_ZP'                          => 'dhw_circulation_pump_switching_times_a1m1',
    'AutomaticFlag_ZPM2'                            => 'dhw_circulation_pump_switching_times_mode_m2',
    'Schaltzeiten_M2_ZP'                            => 'dhw_circulation_pump_switching_times_m2',
    'Schaltzeiten_A1M1_WW'                          => 'dhw_switching_times_a1m1',
    'Schaltzeiten_M2_WW'                            => 'dhw_switching_times_m2',
    'Schaltzeiten_A1M1_HK'                          => 'heating_circuit_switching_times_a1m1',
    'Schaltzeiten_M2_HK'                            => 'heating_circuit_switching_times_m2',
    'WW_Status_NR1'                                 => 'dhw_status_nr1',
    'TiefpassTemperaturwert_VTS'                    => 'flow_temperature_adjusted',
    'DigitalAusgang_Zirkulationspumpe'              => 'circulation_pump_status',
    'DigitalAusgang_Speicherladepumpe'              => 'storage_tank_charging_pump_status',
    'DigitalAusgang_Brenner'                        => 'burner_stage_1_status',
    'DigitalAusgang_Benner2'                        => 'burner_stage_2_status',
    'DigitalEingang_BrennerStoerung'                => 'burner_fault_status',
    'HK_AufheiztimerA1M1'                           => 'heating_circuit_heat_up_phase_timer_a1m1',
    'HK_AufheiztimerM2'                             => 'heating_circuit_heat_up_phase_timer_m2',
    'HK_PumpenbefehlA1M1'                           => 'heating_circuit_pump_command_status_a1m1',
    'HK_PumpenbefehlM2'                             => 'heating_circuit_pump_command_status_m2',
    'HK_SchnellkorrekturA1M1'                       => 'heating_circuit_quick_correction_a1m1',
    'HK_SchnellkorrekturM2'                         => 'heating_circuit_quick_correction_m2',
    'TemperaturFehler_ATS'                          => 'outside_temperature_error_status',
    'SystemIdent_SX'                                => 'device_group',
    'Sachnummer'                                    => 'part_number',
    'KesselSolltemperaturwert'                      => 'boiler_temperature_desired',
    'DigitalAusgang_21'                             => 'digital_output_21',
    'DigitalAusgang_28'                             => 'digital_output_28',
    'HK_WW_Freigabe_vonA1M1'                        => 'dhw_release_a1m1',
    'HK_WW_Freigabe_vonM2'                          => 'dhw_release_m2',
    'D_Ausgang20_M2'                                => 'digital_output_20_m2',
    'ecnsysFehlerhistorie0'                         => 'system_error_history_0',
    'ecnsysFehlerhistorie1'                         => 'system_error_history_1',
    'ecnsysFehlerhistorie2'                         => 'system_error_history_2',
    'ecnsysFehlerhistorie3'                         => 'system_error_history_3',
    'ecnsysFehlerhistorie4'                         => 'system_error_history_4',
    'ecnsysFehlerhistorie5'                         => 'system_error_history_5',
    'ecnsysFehlerhistorie6'                         => 'system_error_history_6',
    'ecnsysFehlerhistorie7'                         => 'system_error_history_7',
    'ecnsysFehlerhistorie8'                         => 'system_error_history_8',
    'ecnsysFehlerhistorie9'                         => 'system_error_history_9',
    'DigitalAusgang_20'                             => 'digital_output_20',
    'DigitalAusgang_52Auf'                          => 'digital_output_52_open',
    'DigitalAusgang_52Zu'                           => 'digital_output_52_closed',
    'FB_A1_SW_Index'                                => 'remote_control_software_index_a1m1',
    'FB_M2_SW_Index'                                => 'remote_control_software_index_m2',
    'Oelverbrauch'                                  => 'fuel_consumption',
    'Oelverbrauch_Reset'                            => 'fuel_consumption_reset',
    'Nachtkontakt_HKPA1'                            => 'heating_circuit_pump_night_contact_a1m1',
    'Nachtkontakt_HKPM2'                            => 'heating_circuit_pump_night_contact_m2',
    'ResetCounter'                                  => 'reset_counter',
    'RelaistestV200KW2_NR1'                         => 'relay_test_v200kw2_nr1',
  }

  # mapped_id = exact_mappings.fetch(id, id.gsub('~', '_'))
  id.gsub('~', '_')
end

def map_data_type(type_id, type)
  byte_length = type.fetch('byte_length')
  bits = byte_length * 8

  data_type, raw_type = case unit = [type['sdk_data_type'], type['parameter']]
  when ['DateTime', 'Array']
    ['sys_time', 'array']
  when ['Byte', 'Byte'], ['Int', 'Byte'], ['Byte', 'Int']
    ["int", "u8"]
  when ['Int', 'Int']
    ["int", 'u16']
  when ['Int', 'Int4']
    ["int", "u32"]
  when ['Int', 'IntHighByteFirst']
    raise type.inspect if bits != 8
    ["int", "u8"]
  when ['Int', 'SByte']
    ["int", "i8"]
  when ['Int', 'SInt']
    ["int", "i16"]
  when ['Int', 'SInt4']
    ["int", "i32"]
  when ['Int', 'SIntHighByteFirst']
    raise type.inspect if bits != 8
    ["int", "i8"]
  when ['Int', 'Array']
    ['int', "u#{bits}"]
  when ['Double', 'Byte']
    ['double', "u8"]
  when ['Double', 'Int']
    ['double', "u16"]
  when ['Double', 'Int4']
    ['double', "u32"]
  when ['Double', 'IntHighByteFirst']
    raise type.inspect if bits != 8
    ['double', "u8"]
  when ['Double', 'SByte']
    ['double', "i8"]
  when ['Double', 'SInt']
    ['double', "i16"]
  when ['Double', 'SIntHighByteFirst']
    raise type.inspect if bits != 8
    ['double', "i8"]
  when ['Double', 'Array']
    if bits <= 16
      ['double', "u#{bits}"]
    else
      ['double', "u#{bits}"]
    end
  when ['ByteArray', 'Byte']
    ['array', 'u8']
  when ["ByteArray", "Int"]
    ['array', "u16"]
  when ["ByteArray", "Int4"]
    ['array', "u32"]
  when ["ByteArray", "SInt"]
    ['array', "i16"]
  when ['Binary', 'Byte']
    ['string', 'array']
  when ['ByteArray', 'Array'], ['ByteArray', 'String']
    if type['url'] == "~/Service/DeviceCircuitTimes.aspx"
      ['cycle_times', 'array']
    else
      case type_id
      when /Fehlerhistorie\d$/, 'ecnsysErrorBuffer', 'ecnsysEventType~ErrorIndex'
        ['error', 'array']
      else
        ["array", 'array']
      end
    end
  when ['Byte', 'String'], ['String', 'String'], ['String', 'Int4']
    ['string', 'array']
  else
    raise "No mapping for type #{unit} for #{type_id}."
  end
end

def map_conversion(conversion)
  case conversion
  when 'NoConversion', 'GWG_2010_Kennung~0x00F9', nil
    'None'
  when 'IPAddress'
    'IpAddress'
  when /\AMult/
    conversion.sub(/\AMult/, 'Mul')
  when 'HexByte2UTF16Byte'
    'HexByte2Utf16Byte'
  else
    conversion
  end
end

def strip_address(s)
  s.sub(/[~+](:?0x|hx)?\h{4}\Z/, '')
end

def load_yaml(path)
  YAML.safe_load(File.read(path), [Symbol])
end

def type_to_command(type_id, type, mappings:, translations:)
  command = {}

  id = map_command_id(type_id)
  command['id'] = id
  command['type_id'] = type_id
  command['description'] = type.fetch('description', 'N/A')

  command['addr'] = type.fetch('address')
  command['mode'] = type.fetch('access_mode')

  data_type, raw_type = map_data_type(type_id, type)
  command['data_type'] = data_type
  command['raw_type'] = raw_type
  command['unit'] = type['unit']
  command['conversion'] = map_conversion(type['conversion'])
  command['conversion_factor'] = type['conversion_factor']
  command['conversion_offset'] = type['conversion_offset']
  command['block_len'] = type.fetch('block_length')
  command['byte_len'] = type.fetch('byte_length')
  command['byte_pos'] = type.fetch('byte_position')
  command['bit_len'] = type.fetch('bit_length')
  command['bit_pos'] = type.fetch('bit_position')

  value_list = type.fetch('value_list', {})
  enum_type = value_list.any?

  if enum_type
    command['mapping'] = mappings.fetch(:mapping).fetch(type_id)
  end

  command
end

file USED_DEVICES => [DEVICES, MAPPINGS_UNIQUE, USED_COMMANDS] do |t|
  devices, mappings_unique, used_commands = t.sources.map { |source| load_yaml(source) }

  default_error_mapping = mappings_unique.fetch(:mapping).fetch('viessmann.errorcode')

  devices = devices.reduce({}) { |h, (device_id, device)|
    h.merge({
      device_id => {
        'id' => device.fetch('identification'),
        'id_ext' => device.fetch('identification_extension'),
        'id_ext_till' => device.fetch('identification_extension_till'),
        'f0' => device.fetch('f0'),
        'f0_till' => device.fetch('f0_till'),
        'commands' => device['event_types']
          .map { |command_name| map_command_id(command_name) }
          .select { |id| used_commands.key?(id) }
          .uniq,
          'error_mapping' => mappings_unique.fetch(:mapping).fetch("viessmann.errorcode.#{device_id}", default_error_mapping),
      }
    })
  }

  File.write t.name, devices.to_yaml
end

task :default => [USED_DEVICES, USED_COMMANDS, USED_MAPPINGS, USED_TRANSLATIONS]

task :clean do
  rm Dir.glob('*.yml')
end
