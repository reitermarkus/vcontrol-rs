require "active_support"
require "active_support/core_ext"
require 'json'
require 'nokogiri'
require 'pathname'
require 'yaml'
require 'open3'

Dir.chdir __dir__

ActiveSupport::Inflector.inflections(:en) do |inflect|
  inflect.acronym 'A1M1'
  inflect.acronym 'M2'
end

class Pathname
  alias to_str to_s
end

class Hash
  def sort_by_key
    map { |k, v| [k, v.is_a?(Hash) ? v.sort_by_key : v] }.sort_by { |k,| k }.to_h
  end
end

VITOSOFT_EXE = 'Vitosoft300SID1_Setup.exe'
VITOSOFT_DIR = 'Vitosoft300SID1_Setup'

DEFINITIONS            = "#{VITOSOFT_DIR}/data/OFFLINE/1477A66B/9BDD2692/DPDefinitions.xml"
DATAPOINT_TYPES_XML    = "#{VITOSOFT_DIR}/data/OFFLINE/3C8BB38F/67C8D997/ecnDataPointType.xml"
EVENT_TYPES_XML        = "#{VITOSOFT_DIR}/data/OFFLINE/3C8BB38F/67C8D997/ecnEventType.xml"
SYSTEM_EVENT_TYPES_XML = "#{VITOSOFT_DIR}/data/OFFLINE/3C8BB38F/67C8D997/sysEventType.xml"
TEXT_RESOURCES_DIR     = "#{VITOSOFT_DIR}/data/OFFLINE/C6C1A272/BF368101"
RELEASE_NOTES          = "#{VITOSOFT_DIR}/data/OFFLINE/C6C1A272/69ADA3A4/ReleaseNotes_en.htm"

TRANSLATIONS_RAW = 'translations_raw.yml'
DEVICES_RAW = 'devices_raw.yml'
DEVICES = 'devices.yml'
SYSTEM_EVENT_TYPES_RAW = 'system_event_types_raw.yml'
EVENT_TYPES_RAW = 'event_types_raw.yml'
VITOSOFT_VERSION = 'vitosoft_version.yml'
MAPPINGS_UNIQUE = 'mappings_unique.yml'
TRANSLATIONS_UNIQUE = 'translations_unique.yml'
USED_COMMANDS = 'used_commands.yml'
USED_MAPPINGS = 'used_mappings.yml'
USED_TRANSLATIONS = 'used_translations.yml'
USED_DEVICES = 'used_devices.yml'

file VITOSOFT_VERSION => RELEASE_NOTES do |t|
  /Release\s+(?<version>\d+\.\d+\.\d+\.\d+)\s+\((?<day>\d+)\.(?<month>\d+)\.(?<year>\d+)\)/ =~ File.read(t.source)
  File.write t.name, {version: version, release_date: "#{year}-#{month}-#{day}"}.to_yaml
end

rule %r{#{Regexp.escape(VITOSOFT_DIR)}/(.*)} => VITOSOFT_EXE do |t|
  sh '7z', 'x', '-y', "-o#{VITOSOFT_DIR}", t.source, Pathname(t.name).relative_path_from(VITOSOFT_DIR)

  Dir.glob(t.name).each do |path|
    next unless File.extname(path) == '.xml'
    sh 'xmllint', '--format', path, '--output', path
  end

  touch t.name
end

file TRANSLATIONS_RAW => TEXT_RESOURCES_DIR.to_s do |t|
  languages = {}
  translations = {}

  Pathname(t.source).glob('Textresource_*.xml').each do |text_resource|
    reader = Nokogiri::XML::Reader(text_resource.open)

    reader.each do |node|
      case node.name
      when 'Culture'
        id = node.attribute('Id')
        name = node.attribute('Name')

        languages[id] ||= name
      when 'TextResource'
        language_id = node.attribute('CultureId')
        label = node.attribute('Label')
        value = node.attribute('Value').strip.gsub('##ecnnewline##', "\n").gsub('##ecntab##', "\t").gsub('##ecnsemicolon##', ';').gsub('##nl##', "\n")

        if /~(?<index>\d+)$/ =~ label
          value = clean_enum_text(index, value)
        end

        translations[label] ||= {}
        translations[label][languages.fetch(language_id)] = value
      end
    end
  end

  File.write t.name, translations.sort_by_key.to_yaml
end

file DEVICES => [DEVICES_RAW, EVENT_TYPES_RAW, SYSTEM_EVENT_TYPES_RAW] do |t|
  devices_raw, event_types_raw, system_event_types_raw =
    t.sources.map { |source| load_yaml(source) }

  types = event_types_raw.merge(system_event_types_raw)

  devices = devices_raw.map { |device_id, v|
    v[:protocol] = device_id.match?(/kw2/i) ? 'Kw2' : 'P300'
    v[:event_types] = v[:event_types].select { |type_id|
      # Remove unneeded/unsupported event types.
      next if type_id.start_with?('Node_')
      next if type_id.start_with?('nciNet')

      type = types.fetch(type_id)
      fc_read = type[:fc_read]
      fc_write = type[:fc_write]
      next if fc_read.nil? && fc_write.nil?
      next unless fc_read == 'virtual_read' || fc_write == 'virtual_write'

      true
    }
    [device_id, v]
  }.to_h

  DUMMY_TYPES = ['ecnStatusEventType', 'ecnsysEventType~Error', 'ecnsysEventType~ErrorIndex']
  devices.delete_if { |k, v|
    # Remove unsupported devices.
    next true if k.start_with?('DEKATEL_')
    next true if k.start_with?('Dekamatik_')
    next true if k.start_with?('Solartrol_')
    next true if k.start_with?('GWG_')
    next true if k.start_with?('MBus_')
    next true if k.start_with?('HV_')
    next true if k.start_with?('HV_')
    next true if k.start_with?('Vitocom')
    next true if k.start_with?('Vitogate')
    next true if k.start_with?('WILO')
    next true if k.start_with?('_VITODATA')

    # Remove devices without any supported event types.
    next true if (v[:event_types] - DUMMY_TYPES).empty?

    false
  }

  File.write t.name, devices.sort_by_key.to_yaml
end

# Remove enum number from text representation if present.
def clean_enum_text(id, text)
  id = Regexp.escape(id)
  text.sub(/^(?:#{id}(?::)?\s+|\(0#{id}\))([^\s]+)/, '\1').strip
end

file USED_COMMANDS => [DEVICES, EVENT_TYPES_RAW, SYSTEM_EVENT_TYPES_RAW, MAPPINGS_UNIQUE, TRANSLATIONS_UNIQUE] do |t|
  devices, event_types_raw, system_event_types_raw, mappings_unique, translations_unique =
    t.sources.map { |source| load_yaml(source) }
  used_event_type_ids = devices.each_value.reduce(Set.new) { |s, v| s | v[:event_types].to_set }

  used_event_types = system_event_types_raw.merge(event_types_raw.keep_if { |type_id,|
    used_event_type_ids.include?(type_id)
  })

  printed_ids = Set.new

  File.open(t.name, 'w+') do |f|
    used_event_types.each do |type_id, type|
      # TODO: Merge duplicate comands.
      next unless printed_ids.add?(map_command_id(type_id))

      f.puts type_to_command(type_id, type, mappings: mappings_unique, translations: translations_unique)
    end
  end
end

file USED_MAPPINGS => [USED_COMMANDS, MAPPINGS_UNIQUE, TRANSLATIONS_UNIQUE] do |t|
  used_commands, mappings_unique, translations_unique = t.sources.map { |source| load_yaml(source) }
  used_commands = used_commands.map { |_, v| v.fetch('type_id') }.to_set

  used_mappings = mappings_unique.fetch(:mapping)
    .select { |k, _| used_commands.include?(k) || k.start_with?('viessmann.errorcode.') }
    .map { |_, k| [k, mappings_unique.fetch(:translations).fetch(k)] }
    .to_h

  File.write t.name, used_mappings.to_yaml
end

file USED_TRANSLATIONS => [USED_MAPPINGS, TRANSLATIONS_UNIQUE] do |t|
  used_mappings, translations_unique = t.sources.map { |source| load_yaml(source) }

  used_translations = used_mappings.flat_map { |_, translations|
    translations.map { |mapping_index, translation_id|
      translation = translations_unique.fetch(:translations).fetch(translation_id).fetch('en')

      [
        translation_id,
        clean_enum_text(mapping_index.to_s, translation).downcase
      ]
    }
  }.to_h

  File.write t.name, used_translations.to_yaml
end

file MAPPINGS_UNIQUE => TRANSLATIONS_UNIQUE do |t|
  translations = load_yaml(t.sources.first).fetch(:mapping)

  mappings = {}

  translations.each do |k, translation|
    if /^viessmann\.eventvaluetype\.(?<id>.*)~(?<value>.*)$/ =~ k
      mappings[id] ||= {}
      mappings[id][value.to_i] = translation
    elsif /^(?<id>viessmann\.errorcode\.[^.]+)\.(?<value>..)$/ =~ k
      mappings[id] ||= {}
      mappings[id][value.to_i(16)] = translation
    end
  end

  File.write t.name, create_mapping_to_unique(mappings).to_yaml
end

task :check_error_mappings => MAPPINGS_UNIQUE do |t|
  mappings = load_yaml(t.source)

  codes = {}

  mappings.each do |k, v|
    next unless /^viessmann\.errorcode\.(?<id>[^.]+)$/ =~ k

    v.each do |value, translation|
      if previous = codes[value]
        next if previous == translation

        $stderr.puts translation

        next if "#{id}.#{value}".in?(['CU401B_S.41', 'Ecotronic.218'])

        raise "Differing value for #{id}.#{value}"
      else
        codes[value] = translation
      end
    end
  end
end

def create_mapping_to_unique(input)
  reversed = {}

  input.each do |k, v|
    reversed[v] ||= []
    reversed[v] << k
    reversed[v] = reversed[v].sort.uniq
  end

  mapping = {}
  combined = {}

  reversed.each do |k, v|
    require 'digest'

    new_id = Digest::MD5.hexdigest(v.sort_by(&:length).first)

    v.each do |old_id|
      mapping[old_id] = new_id
    end

    combined[new_id] = k
  end

  {
    mapping: mapping,
    translations: combined,
  }.sort_by_key
end

file TRANSLATIONS_UNIQUE => TRANSLATIONS_RAW do |t|
  translations = load_yaml(t.sources.first)
  File.write t.name, create_mapping_to_unique(translations).to_yaml
end

def map_command_id(id)
  exact_mappings = {
    'NRF_TiefpassTemperaturwert_PTSO'               => 'buffer_temperature_actual_1',
    'NRF_TiefpassTemperaturwert_PTSU'               => 'buffer_temperature_actual_2',
    'NRF_Temperaturanstieg_STSSOL'                  => 'buffer_temperature_desired',
    'NRF_Temperaturanstieg_PTSU'                    => 'buffer_temperature_actual_3',
    'NRF_Temperaturanstieg_VTSM2'                   => 'buffer_temperature_average',
    'SC100_KesselIsttemperatur'                     => 'boiler_temperature_actual',
    'SC100_Flammtemperatur'                         => 'flame_temperature_actual',
    'SC100_Einschubtemperatur'                      => 'slot_temperature_actual',
    'VT_SolltemperaturA1M1'                         => 'flow_temperature_desired_a1m1',
    'Ausgang52_Mischerposition_M1'                  => 'mixer_position_m1',
    'HK_Mischerposition_akt_M1'                     => 'mixer_position_m1',
    'VorlauftemperaturM1'                           => 'flow_temperature_actual_m1',
    'ADC_Isttemperaturwert_2'                       => 'flow_temperature_actual_m1',
    'Temperatur_2_M1'                               => 'flow_temperature_actual_m1',
    'VT_SolltemperaturM2'                           => 'flow_temperature_desired_m1',
    'VorlauftemperaturM2'                           => 'flow_temperature_actual_m2',
    'Temperatur_2_M2'                               => 'flow_temperature_actual_m2',
    'K90_KonfiZeitkonstAussentemperatur'            => 'outside_temperature_damping_time_constant',
    'Gemischte_AT'                                  => 'outside_temperature_damped',

    'BedienBetriebsartA1M1'                         => 'operating_mode_a1m1',
    'BedienBetriebsartM2'                           => 'operating_mode_m2',
    'Geraetekennung_Diode'                          => 'device_identification',
    'TiefpassTemperaturwert_ATS'                    => 'outside_temperature_lowpass',
    'ADC_IstTemperaturwert_ATS'                     => 'outside_temperature_actual',
    'ADC_IstTemperaturwert_AGTS'                    => 'exhaust_temperature_actual',
    'ADC_Isttemperaturwert_KTS'                     => 'boiler_temperature_actual',
    'TiefpassTemperaturwert_STS1'                   => 'dhw_temperature_lowpass',
    'ADC_IstTemperaturwert_STS1'                    => 'dhw_temperature_actual',
    'TemperaturFehler_STS1'                         => 'dhw_temperature_error',
    'Bedien_WW_Solltemperatur'                      => 'dhw_temperature_desired',
    'TemperaturFehler_AGTS'                         => 'exhaust_temperature_error',
    'TiefpassTemperaturwert_AGTS'                   => 'exhaust_temperature_lowpass',
    'AGTemperaturwertMAXBedienFunktionReset'        => 'exhaust_temperature_max_achieved_reset',
    'BedienRTSolltemperaturReduziertA1M1'           => 'room_temperature_desired_reduced_a1m1',
    'BedienRTSolltemperaturReduziertM2'             => 'room_temperature_desired_reduced_m2',
    'BedienRTSolltemperaturA1M1'                    => 'room_temperature_desired_a1m1',
    'BedienRTSolltemperaturM2'                      => 'room_temperature_desired_m2',
    'HK_RaumsolltemperaturaktuellA1M1'              => 'room_temperature_desired_effective_a1m1',
    'HK_RaumsolltemperaturaktuellM2'                => 'room_temperature_desired_effective_m2',
    'TiefpassTemperatur_RTS_A1M1'                   => 'room_temperature_lowpass_a1m1',
    'TiefpassTemperaturwert_RTS_M2'                 => 'room_temperature_lowpass_m2',
    'TiefpassTemperaturwert_KTS_A1'                 => 'flow_temperature_lowpass_a1m1',
    'HK_VT_Solltemperatur_A1M1'                     => 'flow_temperature_desired_a1m1',
    'HK_VT_Solltemperatur_M2'                       => 'flow_temperature_desired_m2',
    'TemperaturFehler_17_NR1'                       => 'return_temperature_error_status',
    'TiefpassTemperaturwert_17_NR1'                 => 'return_temperature_lowpass_nr1',
    'RuecklauftemperaturM2'                         => 'return_temperature_actual_m2',
    'TemperaturFehler_2_NR1'                        => 'flow_temperature_error_status',
    'TiefpassTemperaturwert_2_NR1'                  => 'flow_temperature_lowpass_nr1',
    'WW_SolltemperaturAktuell'                      => 'dhw_temperature_desired_effective',
    'Zubringerpumpe'                                => 'feed_pump',
    'HK_AktuelleBetriebsartA1M1'                    => 'heating_circuit_operating_mode_effective_a1m1',
    'HK_AktuelleBetriebsartM2'                      => 'heating_circuit_operating_mode_effective_m2',
    'FerienBeginnA1M1'                              => 'holiday_departure_date_a1m1',
    'FerienBeginnM2'                                => 'holiday_departure_date_m2',
    'FerienEndeA1M1'                                => 'holiday_return_date_a1m1',
    'FerienEndeM2'                                  => 'holiday_return_date_m2',
    'Brennertyp_aktuell'                            => 'burner_type_effective',
    'Brennerstarts'                                 => 'burner_starts',
    'BedienSparbetriebA1M1'                         => 'economy_mode_a1m1',
    'BedienSparbetriebM2'                           => 'economy_mode_m2',
    'BedienPartybetriebA1M1'                        => 'party_mode_a1m1',
    'BedienPartybetriebM2'                          => 'party_mode_m2',
    'BedienRTSoll_PartyA1M1'                        => 'party_mode_temperature_desired_a1m1',
    'BedienRTSoll_PartyM2'                          => 'party_mode_temperature_desired_m2',
    'BedienNiveauA1M1'                              => 'heating_curve_level_a1m1',
    'BedienNiveauM2'                                => 'heating_curve_level_m2',
    'BedienNeigungA1M1'                             => 'heating_curve_slope_a1m1',
    'BedienNeigungM2'                               => 'heating_curve_slope_m2',
    'TemperaturFehler_KTS'                          => 'boiler_temperature_error_status',
    'VT_SollKesselA1M1_NR1'                         => 'boiler_temperature_desired_a1m1_nr1',
    'VT_SollKesselM2_NR1'                           => 'boiler_temperature_desired_m2_nr1',
    'TiefpassTemperaturwert_KTS'                    => 'boiler_temperature_lowpass',
    'Absenkzeit_gelerntM2'                          => 'setback_period_experience_based',
    'AGTemperaturwertMAX'                           => 'exhaust_temperature_max_achieved',
    'AGTemperaturwertMAXBedien'                     => 'exhaust_temperature_max',
    'Aufheizgradient_gelerntA1M1'                   => 'heat_up_gradient_experience_based_a1m1',
    'Aufheizgradient_gelerntM2'                     => 'heat_up_gradient_experience_based_m2',
    'BetriebsstundenBrenner1Bedienung'              => 'burner_hours_stage_1',
    'BetriebsstundenBrenner1BedienungFunktionReset' => 'burner_hours_stage_1_reset',
    'BetriebsstundenBrenner2Bedienung'              => 'burner_hours_stage_2',
    'BetriebsstundenBrenner2BedienungFunktionReset' => 'burner_hours_stage_2_reset',
    'BrennerstartsFunktionReset'                    => 'burner_starts_reset',
    'HK_FerienbetriebA1M1'                          => 'holiday_program_a1m1',
    'HK_FerienbetriebM2'                            => 'holiday_program_m2',
    'HK_Frostgefahr_aktivA1M1'                      => 'frost_risk_a1m1',
    'HK_Frostgefahr_aktivM2'                        => 'frost_risk_m2',
    'HK_PumpenzustandA1M1'                          => 'heating_circuit_pump_a1m1',
    'HK_PumpenzustandM2'                            => 'heating_circuit_pump_m2',
    'HK_ReglervarianteA1M1'                         => 'controller_version_a1m1',
    'HK_ReglervarianteA1M1_NR1'                     => 'controller_version_a1m1_nr1',
    'HK_ReglervarianteM2'                           => 'controller_version_m2',
    'HK_ReglervarianteM2_NR1'                       => 'controller_version_m2_nr1',
    'Uhrzeit'                                       => 'date_time',
    'AutomaticFlag_WWA1M1'                          => 'dhw_switching_times_mode_a1m1',
    'AutomaticFlag_WWM2'                            => 'dhw_switching_times_mode_m2',
    'AutomaticFlag_ZPA1M1'                          => 'dhw_circulation_pump_switching_times_mode_a1m1',
    'Schaltzeiten_A1M1_ZP'                          => 'dhw_circulation_pump_switching_times_a1m1',
    'AutomaticFlag_ZPM2'                            => 'dhw_circulation_pump_switching_times_mode_m2',
    'Schaltzeiten_M2_ZP'                            => 'dhw_circulation_pump_switching_times_m2',
    'Schaltzeiten_A1M1_WW'                          => 'dhw_switching_times_a1m1',
    'Schaltzeiten_M2_WW'                            => 'dhw_switching_times_m2',
    'Schaltzeiten_A1M1_HK'                          => 'heating_circuit_switching_times_a1m1',
    'Schaltzeiten_M2_HK'                            => 'heating_circuit_switching_times_m2',
    'WW_Status_NR1'                                 => 'dhw_status_nr1',
    'TiefpassTemperaturwert_VTS'                    => 'flow_temperature_adjusted',
    'DigitalAusgang_Zirkulationspumpe'              => 'circulation_pump_status',
    'DigitalAusgang_Speicherladepumpe'              => 'storage_tank_charging_pump_status',
    'DigitalAusgang_Brenner'                        => 'burner_stage_1_status',
    'DigitalAusgang_Benner2'                        => 'burner_stage_2_status',
    'DigitalEingang_BrennerStoerung'                => 'burner_fault_status',
    'HK_AufheiztimerA1M1'                           => 'heating_circuit_heat_up_phase_timer_a1m1',
    'HK_AufheiztimerM2'                             => 'heating_circuit_heat_up_phase_timer_m2',
    'HK_PumpenbefehlA1M1'                           => 'heating_circuit_pump_command_status_a1m1',
    'HK_PumpenbefehlM2'                             => 'heating_circuit_pump_command_status_m2',
    'HK_SchnellkorrekturA1M1'                       => 'heating_circuit_quick_correction_a1m1',
    'HK_SchnellkorrekturM2'                         => 'heating_circuit_quick_correction_m2',
    'TemperaturFehler_ATS'                          => 'outside_temperature_error_status',
    'SystemIdent_SX'                                => 'device_group',
    'Sachnummer'                                    => 'part_number',
    'KesselSolltemperaturwert'                      => 'boiler_temperature_desired',
    'DigitalAusgang_21'                             => 'digital_output_21',
    'DigitalAusgang_28'                             => 'digital_output_28',
    'HK_WW_Freigabe_vonA1M1'                        => 'dhw_release_a1m1',
    'HK_WW_Freigabe_vonM2'                          => 'dhw_release_m2',
    'D_Ausgang20_M2'                                => 'digital_output_20_m2',
    'ecnsysFehlerhistorie0'                         => 'system_error_history_0',
    'ecnsysFehlerhistorie1'                         => 'system_error_history_1',
    'ecnsysFehlerhistorie2'                         => 'system_error_history_2',
    'ecnsysFehlerhistorie3'                         => 'system_error_history_3',
    'ecnsysFehlerhistorie4'                         => 'system_error_history_4',
    'ecnsysFehlerhistorie5'                         => 'system_error_history_5',
    'ecnsysFehlerhistorie6'                         => 'system_error_history_6',
    'ecnsysFehlerhistorie7'                         => 'system_error_history_7',
    'ecnsysFehlerhistorie8'                         => 'system_error_history_8',
    'ecnsysFehlerhistorie9'                         => 'system_error_history_9',
    'DigitalAusgang_20'                             => 'digital_output_20',
    'DigitalAusgang_52Auf'                          => 'digital_output_52_open',
    'DigitalAusgang_52Zu'                           => 'digital_output_52_closed',
    'FB_A1_SW_Index'                                => 'remote_control_software_index_a1m1',
    'FB_M2_SW_Index'                                => 'remote_control_software_index_m2',
    'Oelverbrauch'                                  => 'fuel_consumption',
    'Oelverbrauch_Reset'                            => 'fuel_consumption_reset',
    'Nachtkontakt_HKPA1'                            => 'heating_circuit_pump_night_contact_a1m1',
    'Nachtkontakt_HKPM2'                            => 'heating_circuit_pump_night_contact_m2',
    'ResetCounter'                                  => 'reset_counter',
    'RelaistestV200KW2_NR1'                         => 'relay_test_v200kw2_nr1',
  }

  exact_mappings.fetch(id, id.gsub('~', '_'))
end

def map_data_type(type_id, type)
  byte_length = type.fetch(:byte_length)
  bits = byte_length * 8

  data_type, raw_type = case unit = [type[:sdk_data_type], type[:parameter]]
  when ['DateTime', 'Array']
    ['sys_time', 'array']
  when ['Int', 'Byte']
    ["int", "u8"]
  when ['Int', 'Int']
    ["int", 'u16']
  when ['Int', 'Int4']
    ["int", "u32"]
  when ['Int', 'IntHighByteFirst']
    raise type.inspect if bits != 8
    ["int", "u8"]
  when ['Int', 'SByte']
    ["int", "i8"]
  when ['Int', 'SInt']
    ["int", "i16"]
  when ['Int', 'SInt4']
    ["int", "i32"]
  when ['Int', 'SIntHighByteFirst']
    raise type.inspect if bits != 8
    ["int", "i8"]
  when ['Int', 'Array']
    ['int', "u#{bits}"]
  when ['Double', 'Byte']
    ['double', "u8"]
  when ['Double', 'Int']
    ['double', "u16"]
  when ['Double', 'Int4']
    ['double', "u32"]
  when ['Double', 'IntHighByteFirst']
    raise type.inspect if bits != 8
    ['double', "u8"]
  when ['Double', 'SByte']
    ['double', "i8"]
  when ['Double', 'SInt']
    ['double', "i16"]
  when ['Double', 'SIntHighByteFirst']
    raise type.inspect if bits != 8
    ['double', "i8"]
  when ['Double', 'Array']
    if bits <= 16
      ['double', "u#{bits}"]
    else
      ['double', "u#{bits}"]
    end
  when ['ByteArray', 'Byte']
    ['array', 'u8']
  when ["ByteArray", "Int"]
    ['array', "u16"]
  when ["ByteArray", "SInt"]
    ['array', "i16"]
  when ['ByteArray', 'Array']
    case type_id
    when /Fehlerhistorie\d$/, 'ecnsysErrorBuffer', 'ecnsysEventType~ErrorIndex'
      ['error', 'array']
    else
      ["array", 'array']
    end
  when ['ByteArray', 'String']
    ['string', 'array']
  else
    raise "No mapping for type #{unit} for #{type_id}."
  end
end

def map_factor(type)
  case conversion = type[:conversion]
  when 'NoConversion', nil then nil
  when 'Div2' then 2
  when 'Div10' then 10
  when 'Div100' then 100
  when 'Div1000' then 1000
  when 'Sec2Hour' then 3600
  when 'Mult2' then 0.5
  when 'Mult5' then 0.2
  when 'Mult10' then 0.1
  when 'Mult100' then 0.01
  when 'MultOffset' then
    factor = type.fetch(:conversion_factor)
    offset = type.fetch(:conversion_offset, 0).to_f
    factor.to_f * (10 ** offset)
  when 'DateBCD' then nil
  when 'DateTimeBCD' then nil
  when 'RotateBytes' then nil
  when 'HourDiffSec2Hour' then nil
  when 'UTCDiff2Month' then nil
  when 'HexByte2AsciiByte' then nil
  when 'Estrich' then nil
  when 'FixedStringTerminalZeroes' then nil
  when 'HexByte2DecimalByte' then nil
  when 'Sec2Minute' then nil
  else
    raise "No factor for conversion '#{conversion}'."
  end
end

def strip_address(s)
  s.sub(/\~0x\h{4}\Z/, '')
end

def load_yaml(path)
  YAML.safe_load(File.read(path), [Symbol])
end

def type_to_command(type_id, type, mappings:, translations:)
  f = StringIO.new

  id = map_command_id(type_id)

  addr = type.fetch(:address)
  factor = map_factor(type)
  mode = type.fetch(:access_mode)

  byte_length = type.fetch(:byte_length)
  data_type, raw_type = map_data_type(type_id, type)
  enum_type = type.fetch(:value_list, {}).any?
  block_length = type.fetch(:block_length)
  byte_length = type.fetch(:byte_length)
  byte_position = type.fetch(:byte_position)
  bit_length = type.fetch(:bit_length)
  bit_position = type.fetch(:bit_position)

  # type_translations = translations.fetch(:translations).fetch("viessmann.eventtype.name.#{type_id}", {})

  f.puts "# #{type.fetch(:description, 'N/A').lines.join("  # ")}"
  f.puts "#{id}:"
  f.puts "  type_id: #{type_id}"
  f.puts "  addr: 0x#{addr.to_s(16).rjust(4, '0')}"
  f.puts "  mode: #{mode}"
  f.puts "  data_type: #{data_type}"
  f.puts "  raw_type: #{raw_type}"
  f.puts "  factor: #{factor}"           unless factor.nil?
  f.puts "  block_len: #{block_length}"  unless block_length.zero?
  f.puts "  byte_len: #{byte_length}"    unless byte_length.zero?
  f.puts "  byte_pos: #{byte_position}"  unless byte_position.zero?
  f.puts "  bit_len: #{bit_length}"      unless bit_length.zero?
  f.puts "  bit_pos: #{bit_position}"    unless bit_position.zero?

  if enum_type || data_type == 'error'
    raw_mapping_ids = if data_type == 'error'
      [
        # "viessmann.errorcode.#{device}",
        "viessmann.errorcode.Ecotronic",
      ]
    else
      case type_id
      when 'ecnsysLONCommunicationModul', 'ecnsysLONCommunicationModulWP'
        ['NRF_K76_KonfiKommunikationsmodul']
      when 'ecnsysLONErrorManager'
        ['K79_KonfiFehlerManagerV300_V333']
      else
        [type_id]
      end
    end

    mapping_ids = raw_mapping_ids.map { |id| mappings.fetch(:mapping).fetch(id) }

    f.puts "  mapping: #{mapping_ids.first}"
  end

  f.string
end

file USED_DEVICES => [DEVICES, USED_COMMANDS] do |t|
  devices, used_commands = t.sources.map { |source| load_yaml(source) }

  devices = devices.reduce({}) { |h, (device_id, device)|
    h.merge({
      device_id => {
        'protocol' => device[:protocol],
        'id' => device[:id],
        'commands' => device[:event_types]
          .map { |command_name| map_command_id(command_name) }
          .select { |id| used_commands.key?(id) }
          .uniq
      }
    })
  }

  File.write t.name, devices.to_yaml
end

task :default => [USED_DEVICES, USED_COMMANDS, USED_MAPPINGS, USED_TRANSLATIONS]

def conversion_to_type(conversion, factor, offset)
  return conversion if factor.nil? && offset.nil?

  if conversion == 'MultOffset' && !factor.nil? && offset.nil?
    if factor == (integer_factor = Integer(factor))
      return "Mult#{integer_factor}"
    end
  end

  raise "Conversion #{[conversion, factor, offset]} is not implemented."
end
